<template>
  <div
    ref="scrollContainer"
    class="w-full h-screen flex justify-center px-2 lg:px-0 overflow-y-auto"
  >
    <div class="flex flex-col w-full max-w-2xl h-full">
      <div class="flex flex-col flex-1">
        <div class="w-full lg:pt-4 pb-4">
          <ul class="list-none">
            <template v-for="(group, index) in messageGroups" :key="index">
              <li v-for="message in group.publicMessages" :key="message.id">
                <MessageDisplay
                  :message="message"
                  @editInlineClick="editInline"
                  @regenerateFromMessage="store.regenerateFromMessage"
                />
              </li>
              <li v-if="group.internalMessages.length > 0" class="flex justify-center">
                <button
                  @click="toggleInternalMessages(index)"
                  class="inline-flex items-center px-3 py-1 my-1 text-sm text-gray-500 rounded-full hover:bg-gray-200"
                >
                  <EyeIcon v-if="!internalMessageGroups[index]" class="h-4 w-4 mr-2" />
                  <EyeSlashIcon v-else class="h-4 w-4 mr-2" />
                  <span>
                    {{ internalMessageGroups[index] ? 'Hide' : 'Show' }}
                    {{ group.internalMessages.length }} internal messages
                  </span>
                </button>
              </li>
              <transition-group
                name="internal-messages"
                enter-active-class="transition-all duration-300 ease-out"
                enter-from-class="opacity-0 max-h-0"
                enter-to-class="opacity-100 max-h-[1000px]"
                leave-active-class="transition-all duration-300 ease-in"
                leave-from-class="opacity-100 max-h-[1000px]"
                leave-to-class="opacity-0 max-h-0"
                v-if="internalMessageGroups[index]"
              >
                <li
                  v-for="message in group.internalMessages"
                  :key="message.id"
                  class="overflow-hidden"
                >
                  <MessageDisplay
                    :message="message"
                    @editInlineClick="editInline"
                    @regenerateFromMessage="store.regenerateFromMessage"
                    class="bg-gray-300"
                    style="border: 1px solid rgb(205 205 205)"
                  />
                </li>
              </transition-group>
            </template>
          </ul>
        </div>

        <div id="chat-status" class="w-full py-4">
          <div class="w-full flex justify-center">
            <!-- Display error message if queryStatus is error -->
            <div v-if="queryStatus === 'error'" class="flex flex-col items-center">
              <div>
                <p class="text-red-500">{{ errorMessage }}</p>
              </div>
              <div>
                <BaseButton class="my-4" @click="store.regenerateFromMessage(lastMessage.id)">
                  Regenerate
                </BaseButton>
              </div>
            </div>

            <div v-if="queryStatus === STATUS.RUNNING || queryStatus === STATUS.PENDING">
              <!-- Add loading icon, centered, displayed only if a query is running -->
              <LoaderIcon /><br />
              <!-- Add stop button, centered, displayed only if a query is running -->
              <button
                @click="stopQuery"
                :disabled="queryStatus === STATUS.TO_STOP"
                class="w-full bg-gray-500 text-white py-2 px-4 rounded-sm"
                type="submit"
              >
                Stop
              </button>
            </div>
          </div>
        </div>
      </div>

      <div id="chat-input" class="w-full border-gray-300 bg-white sticky bottom-0 z-10">
        <transition
          enter-active-class="transition-all duration-300 ease-out"
          enter-from-class="opacity-0 transform translate-y-4"
          enter-to-class="opacity-100 transform translate-y-0"
          leave-active-class="transition-all duration-300 ease-in"
          leave-from-class="opacity-100 transform translate-y-0"
          leave-to-class="opacity-0 transform translate-y-4"
        >
          <!-- 3 suggestions generated by AI -->
          <div
            class="flex flex-col"
            v-if="aiSuggestions && aiSuggestions.length && messages.length === 0"
          >
            <SparklesIcon class="h-5 w-5 text-blue-500" />
            <span class="text-blue-700 text-sm font-bold mb-2">AI Suggestions</span>
            <div v-if="aiSuggestions && aiSuggestions.length" class="flex flex-col space-y-2">
              <div
                v-for="(suggestion, index) in aiSuggestions"
                :key="index"
                class="flex items-center space-x-2"
              >
                <button
                  class="rounded-md bg-white px-3.5 py-2 text-sm font-semibold text-blue-900 shadow-xs ring-1 ring-inset ring-blue-300 hover:bg-blue-50 text-left"
                  @click="applySuggestion(suggestion)"
                >
                  {{ suggestion }}
                </button>
              </div>
            </div>
          </div>
        </transition>
        <div id="input-container" class="py-1 lg:py-2">
          <button
            class="inline-flex items-center rounded-md border border-gray-300 bg-white px-2.5 py-0.5 text-sm font-medium leading-5 text-gray-700 shadow-xs hover:bg-gray-50"
            :style="editMode == 'text' ? 'background-color: #e5e7eb' : ''"
            @click="editMode = 'text'"
          >
            Text
          </button>
          <button
            class="inline-flex items-center rounded-md border border-gray-300 bg-white px-2.5 py-0.5 mx-0.5 text-sm font-medium leading-5 text-gray-700 shadow-xs hover:bg-gray-50"
            :style="editMode == 'SQL' ? 'background-color: #e5e7eb' : ''"
            @click="editMode = 'SQL'"
          >
            Editor
          </button>
          <div class="w-full flex py-1 relative" v-if="editMode == 'SQL'">
            <BaseEditor v-model="inputSQL" @run-query="handleSendMessage" />
            <div v-if="inputSQL.trim().length > 0" class="text-gray-300 hover:text-white">
              <SendButtonWithStatus :status="sendStatus" @clicked="handleSendMessage" />
            </div>
          </div>
          <div class="w-full flex py-1 relative" v-else>
            <textarea
              @input="resizeTextarea"
              @keydown.enter="handleEnter"
              ref="inputTextarea"
              class="grow py-2 px-3 pr-10 rounded-sm border border-gray-300"
              rows="1"
              placeholder="Type your message"
              v-model="inputText"
            ></textarea>
            <transition
              enter-active-class="transition-opacity duration-300 ease-out"
              enter-from-class="opacity-0"
              enter-to-class="opacity-100"
              leave-active-class="transition-opacity duration-300 ease-in"
              leave-from-class="opacity-100"
              leave-to-class="opacity-0"
            >
              <div v-if="inputText.trim().length > 0" class="text-gray-300 hover:text-gray-500">
                <SendButtonWithStatus :status="sendStatus" @clicked="handleSendMessage" />
              </div>
            </transition>
          </div>
        </div>
      </div>
    </div>

    <!-- Connection status notification -->
    <div
      v-if="!isConnected"
      class="fixed top-3 bg-red-500 text-white px-4 py-2 rounded-md shadow-lg z-50"
    >
      Socket disconnected
    </div>
  </div>
</template>

<script setup lang="ts">
import BaseButton from '@/components/base/BaseButton.vue'
import BaseEditor from '@/components/base/BaseEditor.vue'
import SendButtonWithStatus from '@/components/icons/SendButtonWithStatus.vue'
import MessageDisplay from '@/components/MessageDisplay.vue'
import axios from '@/plugins/axios'
import { useContextsStore } from '@/stores/contexts'
import { computed, nextTick, onMounted, ref, watch } from 'vue'

import LoaderIcon from '@/components/icons/LoaderIcon.vue'
import { useRoute, useRouter } from 'vue-router'

// Import sparkles from heroicons
import { isConnected, socket } from '@/plugins/socket'
import { STATUS, useConversationsStore } from '@/stores/conversations'
import { EyeIcon, EyeSlashIcon } from '@heroicons/vue/24/outline'
import { SparklesIcon } from '@heroicons/vue/24/solid'

const route = useRoute()
const router = useRouter()

const contextsStore = useContextsStore()

/** CONVERSATION LOGIC **/
const store = useConversationsStore()
const conversationId = computed(() => {
  if (route.params.id === 'new') {
    return null
  }
  return Number(route.params.id)
})
const queryStatus = computed(() => conversation.value?.status ?? 'clear')
const errorMessage = computed(() => conversation.value?.error ?? '')
const lastMessage = computed(() => messages.value[messages.value.length - 1])
const sendStatus = computed(() => {
  // if socket is not connected, return error
  if (!isConnected.value) {
    return 'error'
  }
  // if conversationId is not set, return clear
  if (!conversationId.value) {
    return 'clear'
  }
  // if conversationId is set, return status
  return conversation.value?.status ?? 'clear'
})

/** The current conversation object from the store. */
const conversation = computed(() => {
  return store.getConversationById(Number(conversationId.value))
})
const messages = computed(() => {
  return conversation.value?.messages ?? []
})
/** END CONVERSATION LOGIC **/

/** MESSAGE DISPLAY LOGIC **/
const internalMessageGroups = ref<{ [key: number]: boolean }>({})

const toggleInternalMessages = (index: number) => {
  internalMessageGroups.value[index] = !internalMessageGroups.value[index]
}

const messageGroups = computed(() => {
  const groups = []
  let currentGroup = { publicMessages: [], internalMessages: [] }

  messages.value.filter(shouldDisplayMessage).forEach((message, index) => {
    const isPublic = isPublicMessage(message, index)

    if (isPublic) {
      if (currentGroup.internalMessages.length > 0 || currentGroup.publicMessages.length > 0) {
        groups.push({ ...currentGroup })
        currentGroup = { publicMessages: [], internalMessages: [] }
      }
      currentGroup.publicMessages.push(message)
    } else {
      currentGroup.internalMessages.push(message)
    }
  })

  if (currentGroup.publicMessages.length > 0 || currentGroup.internalMessages.length > 0) {
    groups.push(currentGroup)
  }

  return groups
})

const shouldDisplayMessage = (message, index) => {
  const isEmptyFunctionResponse =
    message.role === 'function' && message.content === '' && message.image === null
  return !isEmptyFunctionResponse
}

const isPublicMessage = (message, index) => {
  const prevMessage = index > 0 ? messages[index - 1] : null
  const isUser = message.role === 'user'
  const isFunction = message.role === 'function'
  const isFunctionAfterUser = isFunction && prevMessage?.role === 'user'
  const isFunctionAfterAnswer = isFunction && prevMessage?.isAnswer
  const isAnwser = message.isAnswer

  return isUser || isFunctionAfterUser || isAnwser || isFunctionAfterAnswer
}
/** END MESSAGE DISPLAY LOGIC **/

/** HANDLE EVENTS **/
const inputTextarea = ref<HTMLTextAreaElement | null>(null)
const inputText = ref('')
const inputSQL = ref('')
const editMode = ref<'text' | 'SQL'>('text')

const handleEnter = (event: KeyboardEvent) => {
  if (!event.shiftKey) {
    handleSendMessage()
  }
}

const handleSendMessage = async () => {
  try {
    await store.sendMessage(
      editMode.value,
      editMode.value === 'text' ? inputText.value : inputSQL.value,
      conversationId.value,
      contextsStore.contextSelected.id
    )
    // After 100ms, clear the input and scroll to bottom.
    setTimeout(() => {
      clearInput()
      scrollToBottom()
    }, 100)
  } catch (error) {
    console.error('Error sending message:', error)
  }
}

const clearInput = () => {
  inputText.value = ''
  inputSQL.value = ''
  resizeTextarea()
}

const resizeTextarea = () => {
  // Wait for next tick to get the updated DOM.
  nextTick(() => {
    inputTextarea.value.style.height = 'auto'
    inputTextarea.value.style.height = inputTextarea.value.scrollHeight + 'px'
  })
}

const editInline = (query: string) => {
  inputSQL.value = query
  editMode.value = 'SQL'
}
/** END HANDLE EVENTS */

onMounted(async () => {
  inputTextarea.value.focus()
  inputTextarea.value.select()

  if (!conversationId.value) {
    // New conversation
    await fetchAISuggestions()
  } else {
    // Existing conversation
    store.fetchMessages(conversationId.value)
  }

  scrollToBottom()
})

// If route changes (user navigates to a different ID)
watch(
  () => conversationId.value,
  (newVal) => {
    console.log('conversationId changed', newVal)
    if (newVal !== null) {
      store.fetchMessages(newVal)
    }
  }
)

/** AI SUGGESTIONS **/
const aiSuggestions = ref([])

watch(
  () => contextsStore.contextSelected,
  async () => {
    aiSuggestions.value = []
    if (!conversationId.value) {
      await fetchAISuggestions()
    }
  }
)

const fetchAISuggestions = async () => {
  try {
    const response = await axios.get(`/api/contexts/${contextsStore.contextSelected.id}/questions`)
    aiSuggestions.value = response.data
  } catch (error) {
    console.error('Error fetching AI suggestions:', error)
    // You might want to set an error state or show a notification to the user here
    aiSuggestions.value = [] // Reset suggestions in case of error
  }
}

const applySuggestion = (suggestion: string) => {
  inputText.value = suggestion
  handleSendMessage()
  // Empty the suggestions
  aiSuggestions.value = []
}
/** END AI SUGGESTIONS **/

const stopQuery = async () => {
  socket.emit('stop', conversationId.value)
}

socket.on('response', (response) => {
  // If we are on the /new page and the response is for a new conversation, redirect to the new conversation
  if (
    conversationId.value === null &&
    !store.getConversationById(Number(response.conversationId))
  ) {
    router.push({ path: `/chat/${response.conversationId}` })
  }
})

// Reference to the scroll container to allow scrolling to bottom
const scrollContainer = ref<HTMLDivElement | null>(null)

const scrollToBottom = () => {
  nextTick(() => {
    if (scrollContainer.value) {
      scrollContainer.value.scrollTop = scrollContainer.value.scrollHeight
    }
  })
}
</script>

<style scoped>
textarea {
  height: auto;
}

.internal-messages-enter-active,
.internal-messages-leave-active {
  transition: all 0.3s ease-in-out;
  overflow: hidden;
}

.internal-messages-enter-from,
.internal-messages-leave-to {
  opacity: 0;
  max-height: 0;
}

.internal-messages-enter-to,
.internal-messages-leave-from {
  opacity: 1;
  max-height: 1000px;
}
</style>
