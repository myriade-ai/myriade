# serializer version: 1
# name: test_dbt_functions_schema
  list([
    dict({
      'description': "Add text to the AI's memory",
      'name': 'DatabaseTool-database__save_to_memory',
      'parameters': dict({
        'properties': dict({
          'text': dict({
            'description': 'The text to add to the memory',
            'title': 'Text',
            'type': 'string',
          }),
        }),
        'required': list([
          'text',
        ]),
        'title': 'Input for `save_to_memory`',
        'type': 'object',
      }),
    }),
    dict({
      'description': 'Run an SQL query on the database and return the result. If the query is a write operation and the configuration is set to "ask for confirmation", the user will be asked to confirm the query. You will only get sample (~20 rows) of the result. You won\'t get the full result.',
      'name': 'DatabaseTool-database__sql_query',
      'parameters': dict({
        'properties': dict({
          'query': dict({
            'description': "The SQL query string to be executed. Don't forget to escape this if you use double quote.",
            'title': 'Query',
            'type': 'string',
          }),
          'title': dict({
            'default': '',
            'description': 'The name/title of the query',
            'title': 'Title',
            'type': 'string',
          }),
        }),
        'required': list([
          'query',
        ]),
        'title': 'Input for `sql_query`',
        'type': 'object',
      }),
    }),
    dict({
      'description': 'Think about the task at hand. It helps to reflect or decompose the situation.',
      'name': 'think',
      'parameters': dict({
        'properties': dict({
          'thought': dict({
            'description': 'A thought to think about.',
            'title': 'Thought',
            'type': 'string',
          }),
        }),
        'required': list([
          'thought',
        ]),
        'title': 'Input for `think`',
        'type': 'object',
      }),
    }),
    dict({
      'description': 'Get the current date as a string. Returns: the current date string in YYYY-MM-DD format',
      'name': 'get_date',
      'parameters': dict({
        'properties': dict({
        }),
        'title': 'Input for `get_date`',
        'type': 'object',
      }),
    }),
    dict({
      'description': "Give the final response from the user demand/query as a text. You can insert a query with it's preview result in the text using the <QUERY:{query_id}> tag. You can insert a chart in the text using the <CHART:{chart_id}> tag. You can insert a document in the text using the <DOCUMENT:{document_id}> tag. Replace {query_id}, {chart_id}, and {document_id} with the actual IDs. Show the query / chart / document only if the user asked for it or if that makes sense to have it.",
      'name': 'answer',
      'parameters': dict({
        'properties': dict({
          'text': dict({
            'title': 'Text',
            'type': 'string',
          }),
        }),
        'required': list([
          'text',
        ]),
        'title': 'Input for `answer`',
        'type': 'object',
      }),
    }),
    dict({
      'description': 'Ask the user a question. Use it to ask for confirmation, for ambiguous queries,    etc. Use it only when it strictly necessary.',
      'name': 'ask_user',
      'parameters': dict({
        'properties': dict({
          'question': dict({
            'description': 'The question to ask the user',
            'title': 'Question',
            'type': 'string',
          }),
        }),
        'required': list([
          'question',
        ]),
        'title': 'Input for `ask_user`',
        'type': 'object',
      }),
    }),
    dict({
      'description': 'Get detailed configuration options for a specific chart type.',
      'name': 'EchartsTool-echarts__get_chart_configuration',
      'parameters': dict({
        'properties': dict({
          'chart_type': dict({
            'description': "The type of chart (e.g., 'line', 'bar', 'pie', 'scatter')",
            'title': 'Chart Type',
            'type': 'string',
          }),
        }),
        'required': list([
          'chart_type',
        ]),
        'title': 'Input for `get_chart_configuration`',
        'type': 'object',
      }),
    }),
    dict({
      'description': 'List all available ECharts chart types with descriptions. Returns: dict: A dictionary containing chart types categorized by their use case',
      'name': 'EchartsTool-echarts__list_chart_types',
      'parameters': dict({
        'properties': dict({
        }),
        'title': 'Input for `list_chart_types`',
        'type': 'object',
      }),
    }),
    dict({
      'description': 'Render a chart (using Echarts 6). This is not shown to the user, but this will create a chart object That you can reference in the answer response. --- Provide the chart_options without the "dataset" parameter We will fill the dataset.source automatically with the SQL result Don\'t forget to Map from Data to Charts (series.encode) using the correct names Don\'t use specific color in the chart_options unless the user asked for it When creating bar charts with ECharts, make sure to set the correct axis types. IMPORTANT: When using formatters with encoded data, use the {@column_name} syntax. For example: - For labels: "formatter": "{@nps_score}%" - For tooltips: "formatter": "Mois: {@mois}<br/>Score NPS: {@nps_score}%" - NOT: "formatter": "{c}%" (this will show [Object Object])',
      'name': 'EchartsTool-echarts__preview_render',
      'parameters': dict({
        '$defs': dict({
          'Axis': dict({
            'properties': dict({
              'axisLabel': dict({
                'anyOf': list([
                  dict({
                    '$ref': '#/$defs/AxisLabel',
                  }),
                  dict({
                    'type': 'null',
                  }),
                ]),
                'default': None,
              }),
              'inverse': dict({
                'anyOf': list([
                  dict({
                    'type': 'boolean',
                  }),
                  dict({
                    'type': 'null',
                  }),
                ]),
                'default': None,
                'title': 'Inverse',
              }),
              'max': dict({
                'anyOf': list([
                  dict({
                    'type': 'integer',
                  }),
                  dict({
                    'type': 'number',
                  }),
                  dict({
                    'type': 'null',
                  }),
                ]),
                'default': None,
                'title': 'Max',
              }),
              'min': dict({
                'anyOf': list([
                  dict({
                    'type': 'integer',
                  }),
                  dict({
                    'type': 'number',
                  }),
                  dict({
                    'type': 'null',
                  }),
                ]),
                'default': None,
                'title': 'Min',
              }),
              'name': dict({
                'anyOf': list([
                  dict({
                    'type': 'string',
                  }),
                  dict({
                    'type': 'null',
                  }),
                ]),
                'default': None,
                'title': 'Name',
              }),
              'type': dict({
                'enum': list([
                  'value',
                  'category',
                  'time',
                  'log',
                ]),
                'title': 'Type',
                'type': 'string',
              }),
            }),
            'required': list([
              'type',
            ]),
            'title': 'Axis',
            'type': 'object',
          }),
          'AxisLabel': dict({
            'properties': dict({
              'formatter': dict({
                'anyOf': list([
                  dict({
                    'type': 'string',
                  }),
                  dict({
                    'type': 'null',
                  }),
                ]),
                'default': None,
                'title': 'Formatter',
              }),
              'interval': dict({
                'default': 0,
                'title': 'Interval',
                'type': 'integer',
              }),
              'rotate': dict({
                'anyOf': list([
                  dict({
                    'type': 'integer',
                  }),
                  dict({
                    'type': 'null',
                  }),
                ]),
                'default': None,
                'title': 'Rotate',
              }),
            }),
            'title': 'AxisLabel',
            'type': 'object',
          }),
          'ChartOptions': dict({
            'properties': dict({
              'dataZoom': dict({
                'anyOf': list([
                  dict({
                    'items': dict({
                      '$ref': '#/$defs/DataZoom',
                    }),
                    'type': 'array',
                  }),
                  dict({
                    'type': 'null',
                  }),
                ]),
                'default': None,
                'title': 'Datazoom',
              }),
              'grid': dict({
                'anyOf': list([
                  dict({
                    '$ref': '#/$defs/GridOptions',
                  }),
                  dict({
                    'type': 'null',
                  }),
                ]),
                'default': None,
              }),
              'series': dict({
                'items': dict({
                  '$ref': '#/$defs/Series',
                }),
                'title': 'Series',
                'type': 'array',
              }),
              'title': dict({
                'anyOf': list([
                  dict({
                    '$ref': '#/$defs/TitleOptions',
                  }),
                  dict({
                    'type': 'null',
                  }),
                ]),
                'default': None,
              }),
              'tooltip': dict({
                'anyOf': list([
                  dict({
                    '$ref': '#/$defs/Tooltip',
                  }),
                  dict({
                    'type': 'null',
                  }),
                ]),
                'default': None,
              }),
              'xAxis': dict({
                '$ref': '#/$defs/Axis',
              }),
              'yAxis': dict({
                '$ref': '#/$defs/Axis',
              }),
            }),
            'required': list([
              'xAxis',
              'yAxis',
              'series',
            ]),
            'title': 'ChartOptions',
            'type': 'object',
          }),
          'DataZoom': dict({
            'properties': dict({
              'end': dict({
                'default': 100,
                'title': 'End',
                'type': 'integer',
              }),
              'start': dict({
                'default': 0,
                'title': 'Start',
                'type': 'integer',
              }),
              'type': dict({
                'enum': list([
                  'inside',
                  'slider',
                ]),
                'title': 'Type',
                'type': 'string',
              }),
            }),
            'required': list([
              'type',
            ]),
            'title': 'DataZoom',
            'type': 'object',
          }),
          'GridOptions': dict({
            'properties': dict({
              'bottom': dict({
                'anyOf': list([
                  dict({
                    'type': 'string',
                  }),
                  dict({
                    'type': 'integer',
                  }),
                ]),
                'default': '10%',
                'title': 'Bottom',
              }),
              'containLabel': dict({
                'default': True,
                'title': 'Containlabel',
                'type': 'boolean',
              }),
              'left': dict({
                'anyOf': list([
                  dict({
                    'type': 'string',
                  }),
                  dict({
                    'type': 'integer',
                  }),
                ]),
                'default': '10%',
                'title': 'Left',
              }),
              'right': dict({
                'anyOf': list([
                  dict({
                    'type': 'string',
                  }),
                  dict({
                    'type': 'integer',
                  }),
                ]),
                'default': '10%',
                'title': 'Right',
              }),
              'top': dict({
                'anyOf': list([
                  dict({
                    'type': 'string',
                  }),
                  dict({
                    'type': 'integer',
                  }),
                ]),
                'default': '10%',
                'title': 'Top',
              }),
            }),
            'title': 'GridOptions',
            'type': 'object',
          }),
          'ItemStyle': dict({
            'properties': dict({
              'color': dict({
                'anyOf': list([
                  dict({
                    'type': 'string',
                  }),
                  dict({
                    'type': 'null',
                  }),
                ]),
                'default': None,
                'title': 'Color',
              }),
            }),
            'title': 'ItemStyle',
            'type': 'object',
          }),
          'Series': dict({
            'properties': dict({
              'encode': dict({
                '$ref': '#/$defs/SeriesEncode',
              }),
              'itemStyle': dict({
                'anyOf': list([
                  dict({
                    '$ref': '#/$defs/ItemStyle',
                  }),
                  dict({
                    'type': 'null',
                  }),
                ]),
                'default': None,
              }),
              'label': dict({
                'anyOf': list([
                  dict({
                    '$ref': '#/$defs/SeriesLabel',
                  }),
                  dict({
                    'type': 'null',
                  }),
                ]),
                'default': None,
              }),
              'type': dict({
                'enum': list([
                  'bar',
                  'line',
                  'pie',
                  'scatter',
                  'heatmap',
                  'boxplot',
                  'candlestick',
                  'radar',
                  'funnel',
                  'gauge',
                  'treemap',
                  'sunburst',
                  'sankey',
                  'graph',
                ]),
                'title': 'Type',
                'type': 'string',
              }),
            }),
            'required': list([
              'type',
              'encode',
            ]),
            'title': 'Series',
            'type': 'object',
          }),
          'SeriesEncode': dict({
            'properties': dict({
              'itemName': dict({
                'anyOf': list([
                  dict({
                    'type': 'string',
                  }),
                  dict({
                    'type': 'null',
                  }),
                ]),
                'default': None,
                'title': 'Itemname',
              }),
              'value': dict({
                'anyOf': list([
                  dict({
                    'type': 'string',
                  }),
                  dict({
                    'type': 'null',
                  }),
                ]),
                'default': None,
                'title': 'Value',
              }),
              'x': dict({
                'anyOf': list([
                  dict({
                    'type': 'string',
                  }),
                  dict({
                    'type': 'null',
                  }),
                ]),
                'default': None,
                'title': 'X',
              }),
              'y': dict({
                'anyOf': list([
                  dict({
                    'type': 'string',
                  }),
                  dict({
                    'type': 'null',
                  }),
                ]),
                'default': None,
                'title': 'Y',
              }),
            }),
            'title': 'SeriesEncode',
            'type': 'object',
          }),
          'SeriesLabel': dict({
            'properties': dict({
              'formatter': dict({
                'anyOf': list([
                  dict({
                    'type': 'string',
                  }),
                  dict({
                    'type': 'null',
                  }),
                ]),
                'default': None,
                'title': 'Formatter',
              }),
              'position': dict({
                'default': 'right',
                'title': 'Position',
                'type': 'string',
              }),
              'show': dict({
                'default': False,
                'title': 'Show',
                'type': 'boolean',
              }),
            }),
            'title': 'SeriesLabel',
            'type': 'object',
          }),
          'TitleOptions': dict({
            'properties': dict({
              'left': dict({
                'anyOf': list([
                  dict({
                    'type': 'string',
                  }),
                  dict({
                    'enum': list([
                      'center',
                      'left',
                      'right',
                    ]),
                    'type': 'string',
                  }),
                ]),
                'default': 'center',
                'title': 'Left',
              }),
              'text': dict({
                'title': 'Text',
                'type': 'string',
              }),
            }),
            'required': list([
              'text',
            ]),
            'title': 'TitleOptions',
            'type': 'object',
          }),
          'Tooltip': dict({
            'properties': dict({
              'formatter': dict({
                'anyOf': list([
                  dict({
                    'type': 'string',
                  }),
                  dict({
                    'type': 'null',
                  }),
                ]),
                'default': None,
                'title': 'Formatter',
              }),
              'trigger': dict({
                'default': 'item',
                'enum': list([
                  'item',
                  'axis',
                ]),
                'title': 'Trigger',
                'type': 'string',
              }),
            }),
            'title': 'Tooltip',
            'type': 'object',
          }),
        }),
        'properties': dict({
          'chart_options': dict({
            '$ref': '#/$defs/ChartOptions',
            'description': 'The options of the chart. A dict, not a json dump',
          }),
          'query_id': dict({
            'description': 'The uuid of the query to execute',
            'title': 'Query Id',
            'type': 'string',
          }),
        }),
        'required': list([
          'chart_options',
          'query_id',
        ]),
        'title': 'Input for `preview_render`',
        'type': 'object',
      }),
    }),
    dict({
      'description': 'Creates a new entity in the semantic model.',
      'name': 'SemanticModel-semantic_model__create_entity',
      'parameters': dict({
        'properties': dict({
          'definition': dict({
            'description': 'The definition of the entity.',
            'title': 'Definition',
            'type': 'string',
          }),
          'entity_name': dict({
            'description': 'The name of the entity to create.',
            'title': 'Entity Name',
            'type': 'string',
          }),
        }),
        'required': list([
          'entity_name',
          'definition',
        ]),
        'title': 'Input for `create_entity`',
        'type': 'object',
      }),
    }),
    dict({
      'description': 'Creates a new issue for an entity.',
      'name': 'SemanticModel-semantic_model__create_issue',
      'parameters': dict({
        'properties': dict({
          'business_entity_id': dict({
            'description': 'The uuid of the entity to create the issue for.',
            'title': 'Business Entity Id',
            'type': 'string',
          }),
          'description': dict({
            'description': "The description of the issue.                You can use markdown.                Give context / table(s) & column(s) / example(s) to help user visualize the issue.                Use the syntax <QUERY:QUERY_ID> to insert a link to a query if that helps.                Explain the severity of the issue if it's high, critical or blocker.",
            'title': 'Description',
            'type': 'string',
          }),
          'scope': dict({
            'description': 'The scope of the issue ("DATA", "BUSINESS", "BOTH", "UNKNOWN"). Data is for pipeline / warehouse, that can be fixed by data engineers with DBT. Business is for operations / process that impact the business.',
            'title': 'Scope',
            'type': 'string',
          }),
          'severity': dict({
            'description': 'The severity of the issue ("LOW", "MEDIUM", "HIGH", "CRITICAL").',
            'title': 'Severity',
            'type': 'string',
          }),
          'title': dict({
            'description': 'The title of the issue. Tell it as a recommendation.',
            'title': 'Title',
            'type': 'string',
          }),
        }),
        'required': list([
          'title',
          'description',
          'severity',
          'scope',
          'business_entity_id',
        ]),
        'title': 'Input for `create_issue`',
        'type': 'object',
      }),
    }),
    dict({
      'description': 'Deletes an entity from the semantic model.',
      'name': 'SemanticModel-semantic_model__delete_entity',
      'parameters': dict({
        'properties': dict({
          'entity_name': dict({
            'description': 'The name of the entity to delete.',
            'title': 'Entity Name',
            'type': 'string',
          }),
        }),
        'required': list([
          'entity_name',
        ]),
        'title': 'Input for `delete_entity`',
        'type': 'object',
      }),
    }),
    dict({
      'description': 'Fetch an issue by id',
      'name': 'SemanticModel-semantic_model__read_issue',
      'parameters': dict({
        'properties': dict({
          'issue_id': dict({
            'title': 'Issue Id',
            'type': 'string',
          }),
        }),
        'required': list([
          'issue_id',
        ]),
        'title': 'Input for `read_issue`',
        'type': 'object',
      }),
    }),
    dict({
      'description': 'Updates the quality of an existing entity.',
      'name': 'SemanticModel-semantic_model__update_entity',
      'parameters': dict({
        'properties': dict({
          'completeness': dict({
            'description': 'The completeness of the entity.',
            'title': 'Completeness',
            'type': 'integer',
          }),
          'definition': dict({
            'description': 'The definition of the entity.',
            'title': 'Definition',
            'type': 'string',
          }),
          'entity_name': dict({
            'description': 'The name of the entity to update.',
            'title': 'Entity Name',
            'type': 'string',
          }),
          'quality_score': dict({
            'description': 'The quality score of the entity.',
            'title': 'Quality Score',
            'type': 'integer',
          }),
          'report': dict({
            'description': 'The quality report of the entity.',
            'title': 'Report',
            'type': 'string',
          }),
          'table_ref': dict({
            'description': 'The table reference of the entity (e.g. "table_name").',
            'title': 'Table Ref',
            'type': 'string',
          }),
        }),
        'required': list([
          'entity_name',
          'definition',
          'completeness',
          'quality_score',
          'report',
          'table_ref',
        ]),
        'title': 'Input for `update_entity`',
        'type': 'object',
      }),
    }),
    dict({
      'description': 'Updates an existing issue.',
      'name': 'SemanticModel-semantic_model__update_issue',
      'parameters': dict({
        'properties': dict({
          'description': dict({
            'description': 'The description of the issue.',
            'title': 'Description',
            'type': 'string',
          }),
          'issue_id': dict({
            'description': 'The id of the issue to update.',
            'title': 'Issue Id',
            'type': 'string',
          }),
          'scope': dict({
            'description': 'The scope of the issue ("DATA", "BUSINESS", "BOTH", "UNKNOWN"). Data is for pipeline / warehouse, that can be fixed by data engineers with DBT. Business is for operations / process that impact the business.',
            'title': 'Scope',
            'type': 'string',
          }),
          'severity': dict({
            'description': 'The severity of the issue ("LOW", "MEDIUM", "HIGH", "CRITICAL").',
            'title': 'Severity',
            'type': 'string',
          }),
          'status': dict({
            'description': 'The status of the issue ("OPEN", "IN_PROGRESS", "DONE").',
            'title': 'Status',
            'type': 'string',
          }),
          'title': dict({
            'description': 'The title of the issue.',
            'title': 'Title',
            'type': 'string',
          }),
        }),
        'required': list([
          'issue_id',
          'status',
          'title',
          'description',
          'scope',
          'severity',
        ]),
        'title': 'Input for `update_issue`',
        'type': 'object',
      }),
    }),
    dict({
      'description': 'List catalog assets and terms with optional filtering',
      'name': 'CatalogTool-catalog__list_assets',
      'parameters': dict({
        'properties': dict({
          'asset_type': dict({
            'anyOf': list([
              dict({
                'type': 'string',
              }),
              dict({
                'type': 'null',
              }),
            ]),
            'default': None,
            'description': 'Filter by type ("DATABASE", "SCHEMA", "TABLE", "COLUMN",',
            'title': 'Asset Type',
          }),
          'limit': dict({
            'default': 10,
            'description': 'Maximum number of results',
            'title': 'Limit',
            'type': 'integer',
          }),
        }),
        'title': 'Input for `list_assets`',
        'type': 'object',
      }),
    }),
    dict({
      'description': 'List all available tags in the catalog',
      'name': 'CatalogTool-catalog__list_tags',
      'parameters': dict({
        'properties': dict({
          'limit': dict({
            'default': 50,
            'description': 'Maximum number of results',
            'title': 'Limit',
            'type': 'integer',
          }),
          'offset': dict({
            'default': 0,
            'description': 'Number of results to skip for pagination',
            'title': 'Offset',
            'type': 'integer',
          }),
        }),
        'title': 'Input for `list_tags`',
        'type': 'object',
      }),
    }),
    dict({
      'description': 'Get detailed information about a specific asset',
      'name': 'CatalogTool-catalog__read_asset',
      'parameters': dict({
        'properties': dict({
          'asset_id': dict({
            'description': 'UUID of the asset',
            'title': 'Asset Id',
            'type': 'string',
          }),
        }),
        'required': list([
          'asset_id',
        ]),
        'title': 'Input for `read_asset`',
        'type': 'object',
      }),
    }),
    dict({
      'description': 'Get detailed information about a specific term',
      'name': 'CatalogTool-catalog__read_term',
      'parameters': dict({
        'properties': dict({
          'term_id': dict({
            'description': 'UUID of the term',
            'title': 'Term Id',
            'type': 'string',
          }),
        }),
        'required': list([
          'term_id',
        ]),
        'title': 'Input for `read_term`',
        'type': 'object',
      }),
    }),
    dict({
      'description': 'Search assets and terms by name, description, urn, tags, or definition. Case-insensitive partial string matching. PostgreSQL: Results ordered by trigram similarity to the query SQLite: Results in no particular order Returns first 50 matches.',
      'name': 'CatalogTool-catalog__search_assets',
      'parameters': dict({
        'properties': dict({
          'asset_type': dict({
            'anyOf': list([
              dict({
                'type': 'string',
              }),
              dict({
                'type': 'null',
              }),
            ]),
            'default': None,
            'description': 'Filter by type ("TABLE", "COLUMN", "TERM").',
            'title': 'Asset Type',
          }),
          'text': dict({
            'description': 'Search query',
            'title': 'Text',
            'type': 'string',
          }),
        }),
        'required': list([
          'text',
        ]),
        'title': 'Input for `search_assets`',
        'type': 'object',
      }),
    }),
    dict({
      'description': 'Search tags by name or description',
      'name': 'CatalogTool-catalog__search_tags',
      'parameters': dict({
        'properties': dict({
          'limit': dict({
            'default': 50,
            'description': 'Maximum number of results',
            'title': 'Limit',
            'type': 'integer',
          }),
          'text': dict({
            'description': 'Search query',
            'title': 'Text',
            'type': 'string',
          }),
        }),
        'required': list([
          'text',
        ]),
        'title': 'Input for `search_tags`',
        'type': 'object',
      }),
    }),
    dict({
      'description': 'Update catalog asset documentation.',
      'name': 'CatalogTool-catalog__update_asset',
      'parameters': dict({
        'properties': dict({
          'ai_suggestion': dict({
            'anyOf': list([
              dict({
                'type': 'string',
              }),
              dict({
                'type': 'null',
              }),
            ]),
            'default': None,
            'description': "Propose description for user review (doesn't replace existing).",
            'title': 'Ai Suggestion',
          }),
          'asset_id': dict({
            'description': 'UUID of the asset to update',
            'title': 'Asset Id',
            'type': 'string',
          }),
          'description': dict({
            'anyOf': list([
              dict({
                'type': 'string',
              }),
              dict({
                'type': 'null',
              }),
            ]),
            'default': None,
            'description': 'Set asset description (replaces existing). Auto-sets status="draft" if null.',
            'title': 'Description',
          }),
          'note': dict({
            'anyOf': list([
              dict({
                'type': 'string',
              }),
              dict({
                'type': 'null',
              }),
            ]),
            'default': None,
            'description': 'Questions/clarifications (user-facing). REPLACES existing note completely.',
            'title': 'Note',
          }),
          'status': dict({
            'anyOf': list([
              dict({
                'type': 'string',
              }),
              dict({
                'type': 'null',
              }),
            ]),
            'default': None,
            'description': '"draft" or "published". Auto-sets "draft" if providing description/tags without status.',
            'title': 'Status',
          }),
          'suggested_tags': dict({
            'anyOf': list([
              dict({
                'items': dict({
                  'type': 'string',
                }),
                'type': 'array',
              }),
              dict({
                'type': 'null',
              }),
            ]),
            'default': None,
            'description': 'Propose tags for review (must exist in catalog). Replaces all when approved.',
            'title': 'Suggested Tags',
          }),
          'tag_ids': dict({
            'anyOf': list([
              dict({
                'items': dict({
                }),
                'type': 'array',
              }),
              dict({
                'type': 'null',
              }),
            ]),
            'default': None,
            'description': 'Apply tags immediately (UUIDs or names). Auto-creates if needed. Replaces all existing tags.',
            'title': 'Tag Ids',
          }),
        }),
        'required': list([
          'asset_id',
        ]),
        'title': 'Input for `update_asset`',
        'type': 'object',
      }),
    }),
    dict({
      'description': 'Create or update a reusable tag',
      'name': 'CatalogTool-catalog__upsert_tag',
      'parameters': dict({
        'properties': dict({
          'description': dict({
            'anyOf': list([
              dict({
                'type': 'string',
              }),
              dict({
                'type': 'null',
              }),
            ]),
            'default': None,
            'description': 'Optional tag description',
            'title': 'Description',
          }),
          'id': dict({
            'anyOf': list([
              dict({
                'type': 'string',
              }),
              dict({
                'type': 'null',
              }),
            ]),
            'default': None,
            'description': 'Optional tag ID for direct updates. If provided, updates the',
            'title': 'Id',
          }),
          'name': dict({
            'description': 'Tag name (unique within database)',
            'title': 'Name',
            'type': 'string',
          }),
        }),
        'required': list([
          'name',
        ]),
        'title': 'Input for `upsert_tag`',
        'type': 'object',
      }),
    }),
    dict({
      'description': 'Create or update a business glossary term',
      'name': 'CatalogTool-catalog__upsert_term',
      'parameters': dict({
        'properties': dict({
          'business_domains': dict({
            'anyOf': list([
              dict({
                'items': dict({
                }),
                'type': 'array',
              }),
              dict({
                'type': 'null',
              }),
            ]),
            'default': None,
            'description': 'List of business domains this term belongs to',
            'title': 'Business Domains',
          }),
          'definition': dict({
            'description': 'Term definition',
            'title': 'Definition',
            'type': 'string',
          }),
          'id': dict({
            'anyOf': list([
              dict({
                'type': 'string',
              }),
              dict({
                'type': 'null',
              }),
            ]),
            'default': None,
            'description': 'Optional term ID for direct updates. If provided, updates the',
            'title': 'Id',
          }),
          'name': dict({
            'description': 'Term name',
            'title': 'Name',
            'type': 'string',
          }),
          'synonyms': dict({
            'anyOf': list([
              dict({
                'items': dict({
                }),
                'type': 'array',
              }),
              dict({
                'type': 'null',
              }),
            ]),
            'default': None,
            'description': 'List of synonymous terms',
            'title': 'Synonyms',
          }),
        }),
        'required': list([
          'name',
          'definition',
        ]),
        'title': 'Input for `upsert_term`',
        'type': 'object',
      }),
    }),
    dict({
      'description': 'Create a new report document with the given title and content.',
      'name': 'DocumentsTool-documents__create_document',
      'parameters': dict({
        'properties': dict({
          'content': dict({
            'description': 'The markdown content of the report (can include <QUERY:id> and <CHART:id> tags)',
            'title': 'Content',
            'type': 'string',
          }),
          'title': dict({
            'description': 'The title of the report',
            'title': 'Title',
            'type': 'string',
          }),
        }),
        'required': list([
          'title',
          'content',
        ]),
        'title': 'Input for `create_document`',
        'type': 'object',
      }),
    }),
    dict({
      'description': 'Delete a range of lines from the document.',
      'name': 'DocumentsTool-documents__delete_lines_from_document',
      'parameters': dict({
        'properties': dict({
          'document_id': dict({
            'description': 'The UUID of the document to edit',
            'title': 'Document Id',
            'type': 'string',
          }),
          'end_line': dict({
            'description': 'The last line to delete (1-indexed, inclusive)',
            'title': 'End Line',
            'type': 'integer',
          }),
          'start_line': dict({
            'description': 'The first line to delete (1-indexed)',
            'title': 'Start Line',
            'type': 'integer',
          }),
        }),
        'required': list([
          'document_id',
          'start_line',
          'end_line',
        ]),
        'title': 'Input for `delete_lines_from_document`',
        'type': 'object',
      }),
    }),
    dict({
      'description': "Replace all occurrences of 'old_string' with 'new_string' in the document.",
      'name': 'DocumentsTool-documents__edit_document',
      'parameters': dict({
        'properties': dict({
          'document_id': dict({
            'description': 'The UUID of the document to edit',
            'title': 'Document Id',
            'type': 'string',
          }),
          'new_string': dict({
            'description': 'The new text to insert in place of the old text',
            'title': 'New String',
            'type': 'string',
          }),
          'old_string': dict({
            'description': 'The text to replace (must match exactly, including whitespace)',
            'title': 'Old String',
            'type': 'string',
          }),
          'reason': dict({
            'description': 'Reason for the edit (for versioning purposes)',
            'title': 'Reason',
            'type': 'string',
          }),
        }),
        'required': list([
          'document_id',
          'old_string',
          'new_string',
          'reason',
        ]),
        'title': 'Input for `edit_document`',
        'type': 'object',
      }),
    }),
    dict({
      'description': 'Insert text at the specified line number.',
      'name': 'DocumentsTool-documents__insert_lines_in_document',
      'parameters': dict({
        'properties': dict({
          'document_id': dict({
            'description': 'The UUID of the document to edit',
            'title': 'Document Id',
            'type': 'string',
          }),
          'line_number': dict({
            'description': 'The line number to insert at (1-indexed)',
            'title': 'Line Number',
            'type': 'integer',
          }),
          'text': dict({
            'description': 'The text to insert',
            'title': 'Text',
            'type': 'string',
          }),
        }),
        'required': list([
          'document_id',
          'line_number',
          'text',
        ]),
        'title': 'Input for `insert_lines_in_document`',
        'type': 'object',
      }),
    }),
    dict({
      'description': 'List all reports/documents for the current database. Returns: A formatted list of reports with their IDs and titles.',
      'name': 'DocumentsTool-documents__list_documents',
      'parameters': dict({
        'properties': dict({
        }),
        'title': 'Input for `list_documents`',
        'type': 'object',
      }),
    }),
    dict({
      'description': 'Read a document with line numbers.',
      'name': 'DocumentsTool-documents__read_document',
      'parameters': dict({
        'properties': dict({
          'document_id': dict({
            'description': 'The UUID of the document to read',
            'title': 'Document Id',
            'type': 'string',
          }),
          'end_line': dict({
            'default': None,
            'description': 'The line number to end reading at (1-indexed)',
            'title': 'End Line',
            'type': 'integer',
          }),
          'start_line': dict({
            'default': 1,
            'description': 'The line number to start reading from (1-indexed)',
            'title': 'Start Line',
            'type': 'integer',
          }),
        }),
        'required': list([
          'document_id',
        ]),
        'title': 'Input for `read_document`',
        'type': 'object',
      }),
    }),
    dict({
      'description': 'Search reports by title or content.',
      'name': 'DocumentsTool-documents__search_documents',
      'parameters': dict({
        'properties': dict({
          'query': dict({
            'description': 'Search query string',
            'title': 'Query',
            'type': 'string',
          }),
        }),
        'required': list([
          'query',
        ]),
        'title': 'Input for `search_documents`',
        'type': 'object',
      }),
    }),
    dict({
      'description': 'Update the document title.',
      'name': 'DocumentsTool-documents__update_document_title',
      'parameters': dict({
        'properties': dict({
          'document_id': dict({
            'description': 'The UUID of the document',
            'title': 'Document Id',
            'type': 'string',
          }),
          'new_title': dict({
            'description': 'The new title for the document',
            'title': 'New Title',
            'type': 'string',
          }),
        }),
        'required': list([
          'document_id',
          'new_title',
        ]),
        'title': 'Input for `update_document_title`',
        'type': 'object',
      }),
    }),
  ])
# ---
# name: test_functions
  list([
    'DatabaseTool-database__save_to_memory',
    'DatabaseTool-database__sql_query',
    'think',
    'get_date',
    'answer',
    'ask_user',
    'EchartsTool-echarts__get_chart_configuration',
    'EchartsTool-echarts__list_chart_types',
    'EchartsTool-echarts__preview_render',
    'SemanticModel-semantic_model__create_entity',
    'SemanticModel-semantic_model__create_issue',
    'SemanticModel-semantic_model__delete_entity',
    'SemanticModel-semantic_model__read_issue',
    'SemanticModel-semantic_model__update_entity',
    'SemanticModel-semantic_model__update_issue',
    'CatalogTool-catalog__list_assets',
    'CatalogTool-catalog__list_tags',
    'CatalogTool-catalog__read_asset',
    'CatalogTool-catalog__read_term',
    'CatalogTool-catalog__search_assets',
    'CatalogTool-catalog__search_tags',
    'CatalogTool-catalog__update_asset',
    'CatalogTool-catalog__upsert_tag',
    'CatalogTool-catalog__upsert_term',
    'DocumentsTool-documents__create_document',
    'DocumentsTool-documents__delete_lines_from_document',
    'DocumentsTool-documents__edit_document',
    'DocumentsTool-documents__insert_lines_in_document',
    'DocumentsTool-documents__list_documents',
    'DocumentsTool-documents__read_document',
    'DocumentsTool-documents__search_documents',
    'DocumentsTool-documents__update_document_title',
  ])
# ---
# name: test_functions_schema
  list([
    dict({
      'description': "Add text to the AI's memory",
      'name': 'DatabaseTool-database__save_to_memory',
      'parameters': dict({
        'properties': dict({
          'text': dict({
            'description': 'The text to add to the memory',
            'title': 'Text',
            'type': 'string',
          }),
        }),
        'required': list([
          'text',
        ]),
        'title': 'Input for `save_to_memory`',
        'type': 'object',
      }),
    }),
    dict({
      'description': 'Run an SQL query on the database and return the result. If the query is a write operation and the configuration is set to "ask for confirmation", the user will be asked to confirm the query. You will only get sample (~20 rows) of the result. You won\'t get the full result.',
      'name': 'DatabaseTool-database__sql_query',
      'parameters': dict({
        'properties': dict({
          'query': dict({
            'description': "The SQL query string to be executed. Don't forget to escape this if you use double quote.",
            'title': 'Query',
            'type': 'string',
          }),
          'title': dict({
            'default': '',
            'description': 'The name/title of the query',
            'title': 'Title',
            'type': 'string',
          }),
        }),
        'required': list([
          'query',
        ]),
        'title': 'Input for `sql_query`',
        'type': 'object',
      }),
    }),
    dict({
      'description': 'Think about the task at hand. It helps to reflect or decompose the situation.',
      'name': 'think',
      'parameters': dict({
        'properties': dict({
          'thought': dict({
            'description': 'A thought to think about.',
            'title': 'Thought',
            'type': 'string',
          }),
        }),
        'required': list([
          'thought',
        ]),
        'title': 'Input for `think`',
        'type': 'object',
      }),
    }),
    dict({
      'description': 'Get the current date as a string. Returns: the current date string in YYYY-MM-DD format',
      'name': 'get_date',
      'parameters': dict({
        'properties': dict({
        }),
        'title': 'Input for `get_date`',
        'type': 'object',
      }),
    }),
    dict({
      'description': "Give the final response from the user demand/query as a text. You can insert a query with it's preview result in the text using the <QUERY:{query_id}> tag. You can insert a chart in the text using the <CHART:{chart_id}> tag. You can insert a document in the text using the <DOCUMENT:{document_id}> tag. Replace {query_id}, {chart_id}, and {document_id} with the actual IDs. Show the query / chart / document only if the user asked for it or if that makes sense to have it.",
      'name': 'answer',
      'parameters': dict({
        'properties': dict({
          'text': dict({
            'title': 'Text',
            'type': 'string',
          }),
        }),
        'required': list([
          'text',
        ]),
        'title': 'Input for `answer`',
        'type': 'object',
      }),
    }),
    dict({
      'description': 'Ask the user a question. Use it to ask for confirmation, for ambiguous queries,    etc. Use it only when it strictly necessary.',
      'name': 'ask_user',
      'parameters': dict({
        'properties': dict({
          'question': dict({
            'description': 'The question to ask the user',
            'title': 'Question',
            'type': 'string',
          }),
        }),
        'required': list([
          'question',
        ]),
        'title': 'Input for `ask_user`',
        'type': 'object',
      }),
    }),
    dict({
      'description': 'Get detailed configuration options for a specific chart type.',
      'name': 'EchartsTool-echarts__get_chart_configuration',
      'parameters': dict({
        'properties': dict({
          'chart_type': dict({
            'description': "The type of chart (e.g., 'line', 'bar', 'pie', 'scatter')",
            'title': 'Chart Type',
            'type': 'string',
          }),
        }),
        'required': list([
          'chart_type',
        ]),
        'title': 'Input for `get_chart_configuration`',
        'type': 'object',
      }),
    }),
    dict({
      'description': 'List all available ECharts chart types with descriptions. Returns: dict: A dictionary containing chart types categorized by their use case',
      'name': 'EchartsTool-echarts__list_chart_types',
      'parameters': dict({
        'properties': dict({
        }),
        'title': 'Input for `list_chart_types`',
        'type': 'object',
      }),
    }),
    dict({
      'description': 'Render a chart (using Echarts 6). This is not shown to the user, but this will create a chart object That you can reference in the answer response. --- Provide the chart_options without the "dataset" parameter We will fill the dataset.source automatically with the SQL result Don\'t forget to Map from Data to Charts (series.encode) using the correct names Don\'t use specific color in the chart_options unless the user asked for it When creating bar charts with ECharts, make sure to set the correct axis types. IMPORTANT: When using formatters with encoded data, use the {@column_name} syntax. For example: - For labels: "formatter": "{@nps_score}%" - For tooltips: "formatter": "Mois: {@mois}<br/>Score NPS: {@nps_score}%" - NOT: "formatter": "{c}%" (this will show [Object Object])',
      'name': 'EchartsTool-echarts__preview_render',
      'parameters': dict({
        '$defs': dict({
          'Axis': dict({
            'properties': dict({
              'axisLabel': dict({
                'anyOf': list([
                  dict({
                    '$ref': '#/$defs/AxisLabel',
                  }),
                  dict({
                    'type': 'null',
                  }),
                ]),
                'default': None,
              }),
              'inverse': dict({
                'anyOf': list([
                  dict({
                    'type': 'boolean',
                  }),
                  dict({
                    'type': 'null',
                  }),
                ]),
                'default': None,
                'title': 'Inverse',
              }),
              'max': dict({
                'anyOf': list([
                  dict({
                    'type': 'integer',
                  }),
                  dict({
                    'type': 'number',
                  }),
                  dict({
                    'type': 'null',
                  }),
                ]),
                'default': None,
                'title': 'Max',
              }),
              'min': dict({
                'anyOf': list([
                  dict({
                    'type': 'integer',
                  }),
                  dict({
                    'type': 'number',
                  }),
                  dict({
                    'type': 'null',
                  }),
                ]),
                'default': None,
                'title': 'Min',
              }),
              'name': dict({
                'anyOf': list([
                  dict({
                    'type': 'string',
                  }),
                  dict({
                    'type': 'null',
                  }),
                ]),
                'default': None,
                'title': 'Name',
              }),
              'type': dict({
                'enum': list([
                  'value',
                  'category',
                  'time',
                  'log',
                ]),
                'title': 'Type',
                'type': 'string',
              }),
            }),
            'required': list([
              'type',
            ]),
            'title': 'Axis',
            'type': 'object',
          }),
          'AxisLabel': dict({
            'properties': dict({
              'formatter': dict({
                'anyOf': list([
                  dict({
                    'type': 'string',
                  }),
                  dict({
                    'type': 'null',
                  }),
                ]),
                'default': None,
                'title': 'Formatter',
              }),
              'interval': dict({
                'default': 0,
                'title': 'Interval',
                'type': 'integer',
              }),
              'rotate': dict({
                'anyOf': list([
                  dict({
                    'type': 'integer',
                  }),
                  dict({
                    'type': 'null',
                  }),
                ]),
                'default': None,
                'title': 'Rotate',
              }),
            }),
            'title': 'AxisLabel',
            'type': 'object',
          }),
          'ChartOptions': dict({
            'properties': dict({
              'dataZoom': dict({
                'anyOf': list([
                  dict({
                    'items': dict({
                      '$ref': '#/$defs/DataZoom',
                    }),
                    'type': 'array',
                  }),
                  dict({
                    'type': 'null',
                  }),
                ]),
                'default': None,
                'title': 'Datazoom',
              }),
              'grid': dict({
                'anyOf': list([
                  dict({
                    '$ref': '#/$defs/GridOptions',
                  }),
                  dict({
                    'type': 'null',
                  }),
                ]),
                'default': None,
              }),
              'series': dict({
                'items': dict({
                  '$ref': '#/$defs/Series',
                }),
                'title': 'Series',
                'type': 'array',
              }),
              'title': dict({
                'anyOf': list([
                  dict({
                    '$ref': '#/$defs/TitleOptions',
                  }),
                  dict({
                    'type': 'null',
                  }),
                ]),
                'default': None,
              }),
              'tooltip': dict({
                'anyOf': list([
                  dict({
                    '$ref': '#/$defs/Tooltip',
                  }),
                  dict({
                    'type': 'null',
                  }),
                ]),
                'default': None,
              }),
              'xAxis': dict({
                '$ref': '#/$defs/Axis',
              }),
              'yAxis': dict({
                '$ref': '#/$defs/Axis',
              }),
            }),
            'required': list([
              'xAxis',
              'yAxis',
              'series',
            ]),
            'title': 'ChartOptions',
            'type': 'object',
          }),
          'DataZoom': dict({
            'properties': dict({
              'end': dict({
                'default': 100,
                'title': 'End',
                'type': 'integer',
              }),
              'start': dict({
                'default': 0,
                'title': 'Start',
                'type': 'integer',
              }),
              'type': dict({
                'enum': list([
                  'inside',
                  'slider',
                ]),
                'title': 'Type',
                'type': 'string',
              }),
            }),
            'required': list([
              'type',
            ]),
            'title': 'DataZoom',
            'type': 'object',
          }),
          'GridOptions': dict({
            'properties': dict({
              'bottom': dict({
                'anyOf': list([
                  dict({
                    'type': 'string',
                  }),
                  dict({
                    'type': 'integer',
                  }),
                ]),
                'default': '10%',
                'title': 'Bottom',
              }),
              'containLabel': dict({
                'default': True,
                'title': 'Containlabel',
                'type': 'boolean',
              }),
              'left': dict({
                'anyOf': list([
                  dict({
                    'type': 'string',
                  }),
                  dict({
                    'type': 'integer',
                  }),
                ]),
                'default': '10%',
                'title': 'Left',
              }),
              'right': dict({
                'anyOf': list([
                  dict({
                    'type': 'string',
                  }),
                  dict({
                    'type': 'integer',
                  }),
                ]),
                'default': '10%',
                'title': 'Right',
              }),
              'top': dict({
                'anyOf': list([
                  dict({
                    'type': 'string',
                  }),
                  dict({
                    'type': 'integer',
                  }),
                ]),
                'default': '10%',
                'title': 'Top',
              }),
            }),
            'title': 'GridOptions',
            'type': 'object',
          }),
          'ItemStyle': dict({
            'properties': dict({
              'color': dict({
                'anyOf': list([
                  dict({
                    'type': 'string',
                  }),
                  dict({
                    'type': 'null',
                  }),
                ]),
                'default': None,
                'title': 'Color',
              }),
            }),
            'title': 'ItemStyle',
            'type': 'object',
          }),
          'Series': dict({
            'properties': dict({
              'encode': dict({
                '$ref': '#/$defs/SeriesEncode',
              }),
              'itemStyle': dict({
                'anyOf': list([
                  dict({
                    '$ref': '#/$defs/ItemStyle',
                  }),
                  dict({
                    'type': 'null',
                  }),
                ]),
                'default': None,
              }),
              'label': dict({
                'anyOf': list([
                  dict({
                    '$ref': '#/$defs/SeriesLabel',
                  }),
                  dict({
                    'type': 'null',
                  }),
                ]),
                'default': None,
              }),
              'type': dict({
                'enum': list([
                  'bar',
                  'line',
                  'pie',
                  'scatter',
                  'heatmap',
                  'boxplot',
                  'candlestick',
                  'radar',
                  'funnel',
                  'gauge',
                  'treemap',
                  'sunburst',
                  'sankey',
                  'graph',
                ]),
                'title': 'Type',
                'type': 'string',
              }),
            }),
            'required': list([
              'type',
              'encode',
            ]),
            'title': 'Series',
            'type': 'object',
          }),
          'SeriesEncode': dict({
            'properties': dict({
              'itemName': dict({
                'anyOf': list([
                  dict({
                    'type': 'string',
                  }),
                  dict({
                    'type': 'null',
                  }),
                ]),
                'default': None,
                'title': 'Itemname',
              }),
              'value': dict({
                'anyOf': list([
                  dict({
                    'type': 'string',
                  }),
                  dict({
                    'type': 'null',
                  }),
                ]),
                'default': None,
                'title': 'Value',
              }),
              'x': dict({
                'anyOf': list([
                  dict({
                    'type': 'string',
                  }),
                  dict({
                    'type': 'null',
                  }),
                ]),
                'default': None,
                'title': 'X',
              }),
              'y': dict({
                'anyOf': list([
                  dict({
                    'type': 'string',
                  }),
                  dict({
                    'type': 'null',
                  }),
                ]),
                'default': None,
                'title': 'Y',
              }),
            }),
            'title': 'SeriesEncode',
            'type': 'object',
          }),
          'SeriesLabel': dict({
            'properties': dict({
              'formatter': dict({
                'anyOf': list([
                  dict({
                    'type': 'string',
                  }),
                  dict({
                    'type': 'null',
                  }),
                ]),
                'default': None,
                'title': 'Formatter',
              }),
              'position': dict({
                'default': 'right',
                'title': 'Position',
                'type': 'string',
              }),
              'show': dict({
                'default': False,
                'title': 'Show',
                'type': 'boolean',
              }),
            }),
            'title': 'SeriesLabel',
            'type': 'object',
          }),
          'TitleOptions': dict({
            'properties': dict({
              'left': dict({
                'anyOf': list([
                  dict({
                    'type': 'string',
                  }),
                  dict({
                    'enum': list([
                      'center',
                      'left',
                      'right',
                    ]),
                    'type': 'string',
                  }),
                ]),
                'default': 'center',
                'title': 'Left',
              }),
              'text': dict({
                'title': 'Text',
                'type': 'string',
              }),
            }),
            'required': list([
              'text',
            ]),
            'title': 'TitleOptions',
            'type': 'object',
          }),
          'Tooltip': dict({
            'properties': dict({
              'formatter': dict({
                'anyOf': list([
                  dict({
                    'type': 'string',
                  }),
                  dict({
                    'type': 'null',
                  }),
                ]),
                'default': None,
                'title': 'Formatter',
              }),
              'trigger': dict({
                'default': 'item',
                'enum': list([
                  'item',
                  'axis',
                ]),
                'title': 'Trigger',
                'type': 'string',
              }),
            }),
            'title': 'Tooltip',
            'type': 'object',
          }),
        }),
        'properties': dict({
          'chart_options': dict({
            '$ref': '#/$defs/ChartOptions',
            'description': 'The options of the chart. A dict, not a json dump',
          }),
          'query_id': dict({
            'description': 'The uuid of the query to execute',
            'title': 'Query Id',
            'type': 'string',
          }),
        }),
        'required': list([
          'chart_options',
          'query_id',
        ]),
        'title': 'Input for `preview_render`',
        'type': 'object',
      }),
    }),
    dict({
      'description': 'Creates a new entity in the semantic model.',
      'name': 'SemanticModel-semantic_model__create_entity',
      'parameters': dict({
        'properties': dict({
          'definition': dict({
            'description': 'The definition of the entity.',
            'title': 'Definition',
            'type': 'string',
          }),
          'entity_name': dict({
            'description': 'The name of the entity to create.',
            'title': 'Entity Name',
            'type': 'string',
          }),
        }),
        'required': list([
          'entity_name',
          'definition',
        ]),
        'title': 'Input for `create_entity`',
        'type': 'object',
      }),
    }),
    dict({
      'description': 'Creates a new issue for an entity.',
      'name': 'SemanticModel-semantic_model__create_issue',
      'parameters': dict({
        'properties': dict({
          'business_entity_id': dict({
            'description': 'The uuid of the entity to create the issue for.',
            'title': 'Business Entity Id',
            'type': 'string',
          }),
          'description': dict({
            'description': "The description of the issue.                You can use markdown.                Give context / table(s) & column(s) / example(s) to help user visualize the issue.                Use the syntax <QUERY:QUERY_ID> to insert a link to a query if that helps.                Explain the severity of the issue if it's high, critical or blocker.",
            'title': 'Description',
            'type': 'string',
          }),
          'scope': dict({
            'description': 'The scope of the issue ("DATA", "BUSINESS", "BOTH", "UNKNOWN"). Data is for pipeline / warehouse, that can be fixed by data engineers with DBT. Business is for operations / process that impact the business.',
            'title': 'Scope',
            'type': 'string',
          }),
          'severity': dict({
            'description': 'The severity of the issue ("LOW", "MEDIUM", "HIGH", "CRITICAL").',
            'title': 'Severity',
            'type': 'string',
          }),
          'title': dict({
            'description': 'The title of the issue. Tell it as a recommendation.',
            'title': 'Title',
            'type': 'string',
          }),
        }),
        'required': list([
          'title',
          'description',
          'severity',
          'scope',
          'business_entity_id',
        ]),
        'title': 'Input for `create_issue`',
        'type': 'object',
      }),
    }),
    dict({
      'description': 'Deletes an entity from the semantic model.',
      'name': 'SemanticModel-semantic_model__delete_entity',
      'parameters': dict({
        'properties': dict({
          'entity_name': dict({
            'description': 'The name of the entity to delete.',
            'title': 'Entity Name',
            'type': 'string',
          }),
        }),
        'required': list([
          'entity_name',
        ]),
        'title': 'Input for `delete_entity`',
        'type': 'object',
      }),
    }),
    dict({
      'description': 'Fetch an issue by id',
      'name': 'SemanticModel-semantic_model__read_issue',
      'parameters': dict({
        'properties': dict({
          'issue_id': dict({
            'title': 'Issue Id',
            'type': 'string',
          }),
        }),
        'required': list([
          'issue_id',
        ]),
        'title': 'Input for `read_issue`',
        'type': 'object',
      }),
    }),
    dict({
      'description': 'Updates the quality of an existing entity.',
      'name': 'SemanticModel-semantic_model__update_entity',
      'parameters': dict({
        'properties': dict({
          'completeness': dict({
            'description': 'The completeness of the entity.',
            'title': 'Completeness',
            'type': 'integer',
          }),
          'definition': dict({
            'description': 'The definition of the entity.',
            'title': 'Definition',
            'type': 'string',
          }),
          'entity_name': dict({
            'description': 'The name of the entity to update.',
            'title': 'Entity Name',
            'type': 'string',
          }),
          'quality_score': dict({
            'description': 'The quality score of the entity.',
            'title': 'Quality Score',
            'type': 'integer',
          }),
          'report': dict({
            'description': 'The quality report of the entity.',
            'title': 'Report',
            'type': 'string',
          }),
          'table_ref': dict({
            'description': 'The table reference of the entity (e.g. "table_name").',
            'title': 'Table Ref',
            'type': 'string',
          }),
        }),
        'required': list([
          'entity_name',
          'definition',
          'completeness',
          'quality_score',
          'report',
          'table_ref',
        ]),
        'title': 'Input for `update_entity`',
        'type': 'object',
      }),
    }),
    dict({
      'description': 'Updates an existing issue.',
      'name': 'SemanticModel-semantic_model__update_issue',
      'parameters': dict({
        'properties': dict({
          'description': dict({
            'description': 'The description of the issue.',
            'title': 'Description',
            'type': 'string',
          }),
          'issue_id': dict({
            'description': 'The id of the issue to update.',
            'title': 'Issue Id',
            'type': 'string',
          }),
          'scope': dict({
            'description': 'The scope of the issue ("DATA", "BUSINESS", "BOTH", "UNKNOWN"). Data is for pipeline / warehouse, that can be fixed by data engineers with DBT. Business is for operations / process that impact the business.',
            'title': 'Scope',
            'type': 'string',
          }),
          'severity': dict({
            'description': 'The severity of the issue ("LOW", "MEDIUM", "HIGH", "CRITICAL").',
            'title': 'Severity',
            'type': 'string',
          }),
          'status': dict({
            'description': 'The status of the issue ("OPEN", "IN_PROGRESS", "DONE").',
            'title': 'Status',
            'type': 'string',
          }),
          'title': dict({
            'description': 'The title of the issue.',
            'title': 'Title',
            'type': 'string',
          }),
        }),
        'required': list([
          'issue_id',
          'status',
          'title',
          'description',
          'scope',
          'severity',
        ]),
        'title': 'Input for `update_issue`',
        'type': 'object',
      }),
    }),
    dict({
      'description': 'List catalog assets and terms with optional filtering',
      'name': 'CatalogTool-catalog__list_assets',
      'parameters': dict({
        'properties': dict({
          'asset_type': dict({
            'anyOf': list([
              dict({
                'type': 'string',
              }),
              dict({
                'type': 'null',
              }),
            ]),
            'default': None,
            'description': 'Filter by type ("DATABASE", "SCHEMA", "TABLE", "COLUMN",',
            'title': 'Asset Type',
          }),
          'limit': dict({
            'default': 10,
            'description': 'Maximum number of results',
            'title': 'Limit',
            'type': 'integer',
          }),
        }),
        'title': 'Input for `list_assets`',
        'type': 'object',
      }),
    }),
    dict({
      'description': 'List all available tags in the catalog',
      'name': 'CatalogTool-catalog__list_tags',
      'parameters': dict({
        'properties': dict({
          'limit': dict({
            'default': 50,
            'description': 'Maximum number of results',
            'title': 'Limit',
            'type': 'integer',
          }),
          'offset': dict({
            'default': 0,
            'description': 'Number of results to skip for pagination',
            'title': 'Offset',
            'type': 'integer',
          }),
        }),
        'title': 'Input for `list_tags`',
        'type': 'object',
      }),
    }),
    dict({
      'description': 'Get detailed information about a specific asset',
      'name': 'CatalogTool-catalog__read_asset',
      'parameters': dict({
        'properties': dict({
          'asset_id': dict({
            'description': 'UUID of the asset',
            'title': 'Asset Id',
            'type': 'string',
          }),
        }),
        'required': list([
          'asset_id',
        ]),
        'title': 'Input for `read_asset`',
        'type': 'object',
      }),
    }),
    dict({
      'description': 'Get detailed information about a specific term',
      'name': 'CatalogTool-catalog__read_term',
      'parameters': dict({
        'properties': dict({
          'term_id': dict({
            'description': 'UUID of the term',
            'title': 'Term Id',
            'type': 'string',
          }),
        }),
        'required': list([
          'term_id',
        ]),
        'title': 'Input for `read_term`',
        'type': 'object',
      }),
    }),
    dict({
      'description': 'Search assets and terms by name, description, urn, tags, or definition. Case-insensitive partial string matching. PostgreSQL: Results ordered by trigram similarity to the query SQLite: Results in no particular order Returns first 50 matches.',
      'name': 'CatalogTool-catalog__search_assets',
      'parameters': dict({
        'properties': dict({
          'asset_type': dict({
            'anyOf': list([
              dict({
                'type': 'string',
              }),
              dict({
                'type': 'null',
              }),
            ]),
            'default': None,
            'description': 'Filter by type ("TABLE", "COLUMN", "TERM").',
            'title': 'Asset Type',
          }),
          'text': dict({
            'description': 'Search query',
            'title': 'Text',
            'type': 'string',
          }),
        }),
        'required': list([
          'text',
        ]),
        'title': 'Input for `search_assets`',
        'type': 'object',
      }),
    }),
    dict({
      'description': 'Search tags by name or description',
      'name': 'CatalogTool-catalog__search_tags',
      'parameters': dict({
        'properties': dict({
          'limit': dict({
            'default': 50,
            'description': 'Maximum number of results',
            'title': 'Limit',
            'type': 'integer',
          }),
          'text': dict({
            'description': 'Search query',
            'title': 'Text',
            'type': 'string',
          }),
        }),
        'required': list([
          'text',
        ]),
        'title': 'Input for `search_tags`',
        'type': 'object',
      }),
    }),
    dict({
      'description': 'Update catalog asset documentation.',
      'name': 'CatalogTool-catalog__update_asset',
      'parameters': dict({
        'properties': dict({
          'ai_suggestion': dict({
            'anyOf': list([
              dict({
                'type': 'string',
              }),
              dict({
                'type': 'null',
              }),
            ]),
            'default': None,
            'description': "Propose description for user review (doesn't replace existing).",
            'title': 'Ai Suggestion',
          }),
          'asset_id': dict({
            'description': 'UUID of the asset to update',
            'title': 'Asset Id',
            'type': 'string',
          }),
          'description': dict({
            'anyOf': list([
              dict({
                'type': 'string',
              }),
              dict({
                'type': 'null',
              }),
            ]),
            'default': None,
            'description': 'Set asset description (replaces existing). Auto-sets status="draft" if null.',
            'title': 'Description',
          }),
          'note': dict({
            'anyOf': list([
              dict({
                'type': 'string',
              }),
              dict({
                'type': 'null',
              }),
            ]),
            'default': None,
            'description': 'Questions/clarifications (user-facing). REPLACES existing note completely.',
            'title': 'Note',
          }),
          'status': dict({
            'anyOf': list([
              dict({
                'type': 'string',
              }),
              dict({
                'type': 'null',
              }),
            ]),
            'default': None,
            'description': '"draft" or "published". Auto-sets "draft" if providing description/tags without status.',
            'title': 'Status',
          }),
          'suggested_tags': dict({
            'anyOf': list([
              dict({
                'items': dict({
                  'type': 'string',
                }),
                'type': 'array',
              }),
              dict({
                'type': 'null',
              }),
            ]),
            'default': None,
            'description': 'Propose tags for review (must exist in catalog). Replaces all when approved.',
            'title': 'Suggested Tags',
          }),
          'tag_ids': dict({
            'anyOf': list([
              dict({
                'items': dict({
                }),
                'type': 'array',
              }),
              dict({
                'type': 'null',
              }),
            ]),
            'default': None,
            'description': 'Apply tags immediately (UUIDs or names). Auto-creates if needed. Replaces all existing tags.',
            'title': 'Tag Ids',
          }),
        }),
        'required': list([
          'asset_id',
        ]),
        'title': 'Input for `update_asset`',
        'type': 'object',
      }),
    }),
    dict({
      'description': 'Create or update a reusable tag',
      'name': 'CatalogTool-catalog__upsert_tag',
      'parameters': dict({
        'properties': dict({
          'description': dict({
            'anyOf': list([
              dict({
                'type': 'string',
              }),
              dict({
                'type': 'null',
              }),
            ]),
            'default': None,
            'description': 'Optional tag description',
            'title': 'Description',
          }),
          'id': dict({
            'anyOf': list([
              dict({
                'type': 'string',
              }),
              dict({
                'type': 'null',
              }),
            ]),
            'default': None,
            'description': 'Optional tag ID for direct updates. If provided, updates the',
            'title': 'Id',
          }),
          'name': dict({
            'description': 'Tag name (unique within database)',
            'title': 'Name',
            'type': 'string',
          }),
        }),
        'required': list([
          'name',
        ]),
        'title': 'Input for `upsert_tag`',
        'type': 'object',
      }),
    }),
    dict({
      'description': 'Create or update a business glossary term',
      'name': 'CatalogTool-catalog__upsert_term',
      'parameters': dict({
        'properties': dict({
          'business_domains': dict({
            'anyOf': list([
              dict({
                'items': dict({
                }),
                'type': 'array',
              }),
              dict({
                'type': 'null',
              }),
            ]),
            'default': None,
            'description': 'List of business domains this term belongs to',
            'title': 'Business Domains',
          }),
          'definition': dict({
            'description': 'Term definition',
            'title': 'Definition',
            'type': 'string',
          }),
          'id': dict({
            'anyOf': list([
              dict({
                'type': 'string',
              }),
              dict({
                'type': 'null',
              }),
            ]),
            'default': None,
            'description': 'Optional term ID for direct updates. If provided, updates the',
            'title': 'Id',
          }),
          'name': dict({
            'description': 'Term name',
            'title': 'Name',
            'type': 'string',
          }),
          'synonyms': dict({
            'anyOf': list([
              dict({
                'items': dict({
                }),
                'type': 'array',
              }),
              dict({
                'type': 'null',
              }),
            ]),
            'default': None,
            'description': 'List of synonymous terms',
            'title': 'Synonyms',
          }),
        }),
        'required': list([
          'name',
          'definition',
        ]),
        'title': 'Input for `upsert_term`',
        'type': 'object',
      }),
    }),
    dict({
      'description': 'Create a new report document with the given title and content.',
      'name': 'DocumentsTool-documents__create_document',
      'parameters': dict({
        'properties': dict({
          'content': dict({
            'description': 'The markdown content of the report (can include <QUERY:id> and <CHART:id> tags)',
            'title': 'Content',
            'type': 'string',
          }),
          'title': dict({
            'description': 'The title of the report',
            'title': 'Title',
            'type': 'string',
          }),
        }),
        'required': list([
          'title',
          'content',
        ]),
        'title': 'Input for `create_document`',
        'type': 'object',
      }),
    }),
    dict({
      'description': 'Delete a range of lines from the document.',
      'name': 'DocumentsTool-documents__delete_lines_from_document',
      'parameters': dict({
        'properties': dict({
          'document_id': dict({
            'description': 'The UUID of the document to edit',
            'title': 'Document Id',
            'type': 'string',
          }),
          'end_line': dict({
            'description': 'The last line to delete (1-indexed, inclusive)',
            'title': 'End Line',
            'type': 'integer',
          }),
          'start_line': dict({
            'description': 'The first line to delete (1-indexed)',
            'title': 'Start Line',
            'type': 'integer',
          }),
        }),
        'required': list([
          'document_id',
          'start_line',
          'end_line',
        ]),
        'title': 'Input for `delete_lines_from_document`',
        'type': 'object',
      }),
    }),
    dict({
      'description': "Replace all occurrences of 'old_string' with 'new_string' in the document.",
      'name': 'DocumentsTool-documents__edit_document',
      'parameters': dict({
        'properties': dict({
          'document_id': dict({
            'description': 'The UUID of the document to edit',
            'title': 'Document Id',
            'type': 'string',
          }),
          'new_string': dict({
            'description': 'The new text to insert in place of the old text',
            'title': 'New String',
            'type': 'string',
          }),
          'old_string': dict({
            'description': 'The text to replace (must match exactly, including whitespace)',
            'title': 'Old String',
            'type': 'string',
          }),
          'reason': dict({
            'description': 'Reason for the edit (for versioning purposes)',
            'title': 'Reason',
            'type': 'string',
          }),
        }),
        'required': list([
          'document_id',
          'old_string',
          'new_string',
          'reason',
        ]),
        'title': 'Input for `edit_document`',
        'type': 'object',
      }),
    }),
    dict({
      'description': 'Insert text at the specified line number.',
      'name': 'DocumentsTool-documents__insert_lines_in_document',
      'parameters': dict({
        'properties': dict({
          'document_id': dict({
            'description': 'The UUID of the document to edit',
            'title': 'Document Id',
            'type': 'string',
          }),
          'line_number': dict({
            'description': 'The line number to insert at (1-indexed)',
            'title': 'Line Number',
            'type': 'integer',
          }),
          'text': dict({
            'description': 'The text to insert',
            'title': 'Text',
            'type': 'string',
          }),
        }),
        'required': list([
          'document_id',
          'line_number',
          'text',
        ]),
        'title': 'Input for `insert_lines_in_document`',
        'type': 'object',
      }),
    }),
    dict({
      'description': 'List all reports/documents for the current database. Returns: A formatted list of reports with their IDs and titles.',
      'name': 'DocumentsTool-documents__list_documents',
      'parameters': dict({
        'properties': dict({
        }),
        'title': 'Input for `list_documents`',
        'type': 'object',
      }),
    }),
    dict({
      'description': 'Read a document with line numbers.',
      'name': 'DocumentsTool-documents__read_document',
      'parameters': dict({
        'properties': dict({
          'document_id': dict({
            'description': 'The UUID of the document to read',
            'title': 'Document Id',
            'type': 'string',
          }),
          'end_line': dict({
            'default': None,
            'description': 'The line number to end reading at (1-indexed)',
            'title': 'End Line',
            'type': 'integer',
          }),
          'start_line': dict({
            'default': 1,
            'description': 'The line number to start reading from (1-indexed)',
            'title': 'Start Line',
            'type': 'integer',
          }),
        }),
        'required': list([
          'document_id',
        ]),
        'title': 'Input for `read_document`',
        'type': 'object',
      }),
    }),
    dict({
      'description': 'Search reports by title or content.',
      'name': 'DocumentsTool-documents__search_documents',
      'parameters': dict({
        'properties': dict({
          'query': dict({
            'description': 'Search query string',
            'title': 'Query',
            'type': 'string',
          }),
        }),
        'required': list([
          'query',
        ]),
        'title': 'Input for `search_documents`',
        'type': 'object',
      }),
    }),
    dict({
      'description': 'Update the document title.',
      'name': 'DocumentsTool-documents__update_document_title',
      'parameters': dict({
        'properties': dict({
          'document_id': dict({
            'description': 'The UUID of the document',
            'title': 'Document Id',
            'type': 'string',
          }),
          'new_title': dict({
            'description': 'The new title for the document',
            'title': 'New Title',
            'type': 'string',
          }),
        }),
        'required': list([
          'document_id',
          'new_title',
        ]),
        'title': 'Input for `update_document_title`',
        'type': 'object',
      }),
    }),
  ])
# ---
# name: test_tools
  dict({
    'catalog': 'CatalogTool',
    'database': 'DatabaseTool',
    'documents': 'DocumentsTool',
    'echarts': 'EchartsTool',
    'semantic_model': 'SemanticModel',
    'workspace': 'WorkspaceTool',
  })
# ---
